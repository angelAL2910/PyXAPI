#!/usr/bin/env python

# This example is a (very!) simplified version of the well known command
# `ping6'. `one_ping6.py' send one ICMPv6 Echo Request to some destination
# via (optional) intermediate nodes. Then it waits for ICMPv6 Echo Reply
# and prints some ancillary data (possibly) received as hop limit and
# routing header.

import random, select, struct, time

from socket_ext import *
from rfc3542 import *

Error = 'Error'
DFLT_TIMEOUT = 5

random.seed()

def make_rth(*addrs):
    """ take a tuple of intermediate nodes and returns the corresponding
    routing header (of type 0). Used by `ICMP6EchoRequest.send' method
    """
    
    rth = inet6_rth()
    rth = inet6_rth_init(rth, IPV6_RTHDR_TYPE_0, len(addrs))
    for addr in addrs:
        inet6_rth_add(rth, addr)
    return rth

class ICMP6EchoRequest(object):
    """ ICMPv6 Echo Request object. 4 attributes:
    self.id_ -> identifier
    self.seq -> sequence number
    self.hdr -> ICMPv6 header as a raw Python string
    self.data -> ICMPv6 Echo Request optional data as a raw Python string
    """
    
    def __init__(self, seq, *data):
        """ initialize ICMPv6 Echo Request (identifier is generated by
        random.randint)
        """
        
        self.id_, self.seq = random.randint(0, 0xffff), seq
        self.hdr = struct.pack(
            '2B3H', ICMP6_ECHO_REQUEST, 0, 0, self.id_, self.seq)
        self.data = data

    def get_id_and_seq(self):
        """ return identifier and sequence number
        """
        
        return self.id_, self.seq

    def send(self, sock, dest, *addrs):
        """ send packet to `dest' via intermediate nodes listed in addrs'
        (`addrs' can be empty). Header and data are 2 distinct elements of
        the scatter/gather array sent.
        """
        
        ad = ()
        if addrs:
            r = apply(make_rth, addrs)
            c = cmsg()
            c.set(IPPROTO_IPV6, IPV6_RTHDR, r.data)
            ad = (c,)
        return sock.sendmsg((dest, 0), (self.hdr,) + self.data, ad)

class ICMP6EchoReplyFromData(object):
    """ builds ICMPv6 Echo Reply from (raw) data received. 2 attributes:
    self.hdr -> header (5-tuple)
    self.data -> optional data (raw string)
    """
    
    HLEN = struct.calcsize('2B3H')
    
    def __init__(self, hdr, data=''):
        """ initialize ICMPv6 Echo Reply from `hdr' (header) and `data'
        (optional data)
        """
        
        if len(hdr) != ICMP6EchoReplyFromData.HLEN:
            raise Error, 'ICMP6EchoReply.__init__: header has bad length'
        self.hdr = struct.unpack('2B3H', hdr)
        self.data =  data

    def __str__(self):
        """ print ICMPv6 Echo Reply
        """
        
        ret = 'ICMPv6 Echo Reply:\n'
        ret += '  Type:\t\t%u\n' % self.hdr[0]
        ret += '  Code:\t\t%u\n' % self.hdr[1]
        ret += '  Checksum:\t0x%.4x\n' % self.hdr[2]
        ret += '  Identifier:\t%u\n' % self.hdr[3]
        ret += '  Sequence:\t%u\n' % self.hdr[4]
        ret += '  Data: \t%d Byte(s)' % len(self.data)
        return ret

    def __repr__(self):
        return str(self)

    def get_id_and_seq(self):
        """ return identifier and sequence number
        """
        
        return self.hdr[3:]

def wait_for_echo_reply(sock, id_, seq, dest, timeout=DFLT_TIMEOUT):
    """ wait for an ICMPv6 Echo Reply (with idendifier `id_' and sequence
    number `seq') until `timeout' expires
    """

    # filtering all ICMPv6 packets except ICMPv6 Echo Reply
    f = icmp6_filter()
    f.ICMP6_FILTER_SETBLOCKALL();
    f.ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY);
    sock.setsockopt(IPPROTO_ICMPV6, ICMP6_FILTER, f.data)
    
    # preparing to receive hop limit and routing header as ancillary data
    h = hoplimit()
    alen = CMSG_SPACE(inet6_rth_space(IPV6_RTHDR_TYPE_0, 100)) + \
           CMSG_SPACE(h.size)
    sock.setsockopt(IPPROTO_IPV6, IPV6_RECVHOPLIMIT, 1)
    sock.setsockopt(IPPROTO_IPV6, IPV6_RECVRTHDR, 1)

    # waiting for ICMPv6 Echo Reply (with `id_' and `seq' as expected)
    to, ts = timeout, time.time()
    while True:
        if select.select([sock], [], [], to)[0] != []:
            to = timeout - (time.time() - ts)
            if to <= 0:
                data = None
                break
            try:
                addr, data, adata, flags = \
                      sock.recvmsg((ICMP6EchoReplyFromData.HLEN, 1024), alen)
                if flags & MSG_TRUNC or flags & MSG_CTRUNC:
                    continue
                data = apply(ICMP6EchoReplyFromData, data)
                if data.get_id_and_seq() == (id_, seq):
                    break
                else:
                    continue
            except:
                continue
        data = None
        break
    if data == None:
        print 'No answer from %s' % dest
        return
    
    # parsing ancillary data
    r = inet6_rth()
    for a in adata:
        if a.cmsg_level == IPPROTO_IPV6 and a.cmsg_type == IPV6_HOPLIMIT:
            h.set_from_data(a.cmsg_data)
        if a.cmsg_level == IPPROTO_IPV6 and a.cmsg_type == IPV6_RTHDR:
            r.set_from_data(a.cmsg_data)
            
    # printing data and ancillary data (possibly) received
    pr = 'Received from %s' % addr[0]
    h = h.get()
    if h != None:
        pr += ' , hoplimit=%d' % h
    print pr
    print data
    r = r.get()
    if r != None:
        print 'with routing header:'
        print '  header:\n  nxt=%d, len=%d, type=%d, segleft=%d' % r[0][:-1]
        print '  segments:'
        for s in r[1:]:
            print '    %s' % s

def send_echo_request(dest, data, seq, *addrs):
    """ build and ICMPv6 Echo Request with sequence number `seq' and (possibly
    empty) data `data'. Then send to destination `dest' via intermediate nodes
    listed in `addrs' (`addrs' can be empty)
    """
    
    pkt = apply(ICMP6EchoRequest, (seq,) + data)
    sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)
    print 'Sending one ICMPv6 Echo Request to %s' % dest
    if addrs:
        print 'via:'
        for a in addrs:
            print '  %s' % a
    pkt.send(sock, dest, *addrs)
    id_, seq = pkt.get_id_and_seq()
    wait_for_echo_reply(sock, id_, seq, dest)
    sock.close()
    
if __name__ == '__main__':
    # To test (`i1', `i2' and `i3' are intermediate nodes, `dest' is
    # destination):
    # >>> ./one_ping6.py -s 123 -d 'This is ' -d 'a test' i1 i2 i3 dest
    # Sending one ICMPv6 Echo Request to iode.ipv6
    # via:
    #   i1
    #   i2
    #   i3
    # Received from 3ffe:200:100:1::53 , hoplimit=49
    # ICMPv6 Echo Reply:
    #   Type:		129
    #   Code:		0
    #   Checksum:	0xc20c
    #   Identifier:	38020
    #   Sequence:       123
    #   Data:           14 Byte(s)
    
    import getopt, sys

    def usage(cmd):
        print 'Usage: %s [-d <data> [-d <data> ...]]' % cmd + \
              ' [-s <sequence number>] \\\n  [-t <timeout>] [i1 [i2 ...]] dest'
        sys.exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], "d:s:t:",
                                   ["data=", "seq=", "timeout=", ])
    except getopt.GetoptError:
        usage(sys.argv[0])
    data, seq, timeout = (), 0, DFLT_TIMEOUT
    for o, a in opts:
        if o in ('-d', '--data'):
           data += (a,) 
        if o in ('-s', '--seq'):
            try:
                seq = int(a)
            except:
                usage(sys.argv[0])
        if o in ('-t', '--timeout'):
            try:
                timeout = int(a)
            except:
                usage(sys.argv[0])
    if len(args) == 0:
        usage(sys.argv[0])
    apply(send_echo_request, [args[-1], data, seq] + args[0:-1])
    sys.exit(0)
